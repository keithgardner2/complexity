<h1>Quicksort (hoare partitioning)</h1>

<p>Quicksort is a fast sorting algorithm developed by Tony Hoare.

<p>Average complexity: O(n log n)<br>
Worst Case: O(n^2)<br>
Best Case: O(n log n)

<h3>Here's quicksort with hoare partitioning, no randomization: (Thanks <a href = "http://huskyalgo.com">Anthony</a>!)</h3>

<code>
    <pre>
        void quicksort_hoare_norand(int *arr, int start, int end){
            if (start >= end){
                return;
            }
        
            int p = hoare_partition(arr, start, end, start);
            quicksort_hoare_norand(arr, start, p);
            quicksort_hoare_norand(arr, p+1, end);
        }
        
        int hoare_partition(int *arr, int start, int end, int pi){
            int i = start-1;
            int j = end+1;
            int pv = arr[pi];
        
            while(1){
                if (global_kill_flag){
                    exit(1);
                }
        
                while(arr[++i] < pv);
                while(arr[--j] > pv);
                    if (i < j){
                        SWAP(arr, i, j);
                    }
                    else{
                        return j;
                    }
            }
        }
                
                </pre>
</code>

<h3> Here's quicksort with hoare partitioning and randomization:</h3>

<code>
    <pre>
        void quicksort_hoare_rand(int *arr, int start, int end){
            if (start >= end){
                return;
            }
        
            int p = hoare_partition(arr, start, end, RAND_RANGE(start, end));
            quicksort_hoare_rand(arr, start, p);
            quicksort_hoare_rand(arr, p+1, end);
        }
        
        int hoare_partition(int *arr, int start, int end, int pi){
            int i = start-1;
            int j = end+1;
            int pv = arr[pi];
        
            while(1){
                if (global_kill_flag){
                    exit(1);
                }
        
                while(arr[++i] < pv);
                while(arr[--j] > pv);
                    if (i < j){
                        SWAP(arr, i, j);
                    }
                    else{
                        return j;
                    }
            }
        }
        
        #define SWAP(arr, x, y)     \
        do {                    \
            int t = arr[x];     \
            arr[x] = arr[y];    \
            arr[y] = t;         \
        } while(0);
        
    </pre>
</code>



<h1>Quicksort (lomuto partitioning)</h1>

<p>Quicksort is a fast sorting algorithm used in many standard libraries. This algorithm can handle large data sets very quickly. Crank the problem size up to a million and watch it complete in about the same time than it takes selection sort to finish on just a few thousand.

<p>Average complexity: O(n log n)<br>
Worst Case: O(n^2)<br>
Best Case: O(n log n)<br>

<h3>Here's quicksort with lomuto partitioning, no randomization: (Thanks <a href = "http://huskyalgo.com">Anthony</a>!)</h3>

<code>
    <pre>
        void quicksort_lomuto_norand(int *arr, int start, int end){
            if (start >= end){
                return;
            }
        
            int p = lomuto_partition(arr, start, end, start);
            quicksort_lomuto_norand(arr, start, p-1);
            quicksort_lomuto_norand(arr, p+1, end);
        }
        
        
        int lomuto_partition(int *arr, int start, int end, int pi){
            int pv = arr[pi];
            int si = start;
        
            SWAP(arr, pi, end);
        
            for (int i = start; i < end; ++i){
                if (global_kill_flag){
                    exit(1);
                    }
            
                if (arr[i] <= pv){
                    SWAP(arr, si, i);
                    ++si;
                }
            }
            
            SWAP(arr, si, end);
            return si;
        }
        
        #define SWAP(arr, x, y)     \
        do {                    \
            int t = arr[x];     \
            arr[x] = arr[y];    \
            arr[y] = t;         \
        } while(0);
            
            
            </pre>
</code>

<h3> Here's quicksort using lomuto partitioning and randomization:</h3>

<code>
    <pre>
        void quicksort_lomuto_rand(int *arr, int start, int end){
            if (start >= end){
                return;
                }
        
            int p = lomuto_partition(arr, start, end, RAND_RANGE(start, end));
            quicksort_lomuto_rand(arr, start, p-1);
            quicksort_lomuto_rand(arr, p+1, end);
        }
        
        int lomuto_partition(int *arr, int start, int end, int pi){
            int pv = arr[pi];
            int si = start;
        
            SWAP(arr, pi, end);
        
            for (int i = start; i < end; ++i){
                if (global_kill_flag){
                    exit(1);
                    }
            
                if (arr[i] <= pv){
                    SWAP(arr, si, i);
                    ++si;
                    }
            }
            
            SWAP(arr, si, end);
            return si;
        }
        
        #define SWAP(arr, x, y)     \
        do {                    \
            int t = arr[x];     \
            arr[x] = arr[y];    \
            arr[y] = t;         \
        } while(0);
            
    </pre>
</code>


<h1>Bubble sort</h1>

<p>Bubble sort is a simple sorting algorithm to implement. As a consequence, bubble sort takes a long time to run if the data is large. This algorithm goes through pairs of data and swaps them if they are in the wrong order, and repeats this until all of the data is sorted.

<p> Average performance: O(n^2)<br>
Worst Case performance: O(n^2)<br>
Best Case performance: O(n)

<h3>Here's the code for a bubblesort in objective-c:</h3>

<code>
    <pre>
        -(void)bubbleSort{
            int i, j;
            for (i = 0; i < problemSize; ++i){
                for (j = i + 1; j < problemSize; ++j){
                    if (data[i] > data[j]){
                        int t = data[i];
                        data[i] = data[j];
                        data[j] = t;
                    }
                }
            }
        }
    </pre>
</code>


<h1>Insertion sort</h1>

<p>Insertion sort is another slow, simple sorting algorithm. This won't take long to run on small data sets, but if you run it on 50,000, you'll be waiting a while.

<p>Average performance: O(n^2)<br>
Worst case performance: O(n^2)<br>
Best case performance: O(n)

<h3>Insertion sort in objective c:</h3>

<code>
    <pre>
        -(void)insertionSort{
            int j, i, key;
            for(j = 1; j < problemSize; j++){
                key = data[j];
                i = j -1;
                while(i > 0 && data[i] > key){
                    data[i + 1] = data[i];
                    i = i -1;
                }
                data[i + 1] = key;
            }
        }
    </pre>
</code>

<h1>Heap sort</h1>

<p>Heap sort is a pretty efficient algorithm.

<p>Average performance: <br>
Worst case performance: <br>
Best case performance: <br>


<h1>Rank sort</h1>

<p> This is a pretty simple working algorithm to implement, and as such is usually slow. The concept is pretty easy is understand: you go through each element of your array, and for each item, you compare and see how it ranks it terms of size. You count the number of items smaller. Then, you insert the item into a second array at that index.

<p>Average performance:<br>
Worst case performance:<br>
Best case performance:

<h3>Here's code in c to sort the data in descending order:</h3>

<code>
    <pre>
        -(void)rankSort{
            int spot;
            int copy[problemSize];
            for(int i = 0; i < problemSize; i++){
                spot = 0;
                for(int j = 0 ; j < problemSize; j++){
                    if(data[i] < data[j] && data[i] != data[j]){
                    spot++;
                    }
                }
                copy[spot] = data[i];
            }
        }
            </pre>
</code>

<h3>... and here's code to put the data in ascending order:</h3>


<h1>Selection Sort</h1>

<p>Selection sort is a fairly simple sorting algorithm to implement.... But, if you run this on 50,000, you'll be waiting a while for it to complete.

<p>Average performance:<br>
Worst case performance:<br>
Best case performance:

<h3> Here's some code...</h3>

<code>
    <pre>
        -(void)selectionSort{
            for(int i = 0; i < problemSize; i++){
                choice = data[i];
                original = choice;
                next = i + 1;
                for(next; next < problemSize; next++){
                    if (!shouldRun){
                        problemSize = 1;
                        continue;
                    }
            
                    if(data[next] < choice){
                        choice = data[next];
                        originalSpot = next;
                    }
            
                }
            data[i] = choice;
            data[originalSpot] = original;
            }
        }
            </pre>
</code>


<h1>Merge sort</h1>

<p>Merge sort uses recursion...

<p>Average performance:<br>
Worst case performance:<br>
Best case performance:

<h3>Here's merge sort in c:</h3>

<code>
    <pre>
        void mergeSort(int *arr, int size){
            int *tmp = malloc(sizeof(int) * size);
            mergesort_aux(arr, tmp, 0, size);
            free(tmp);
        }
        
        void mergesort_aux(int *arr, int *tmp, int start, int end){
            if (end - start <= 1){
                return;
            }
            int mid = (end + start) / 2;
            mergesort_aux(arr, tmp, start, mid);
            mergesort_aux(arr, tmp, mid, end);
            merge(arr, tmp, start, mid, end);
        }
        
        void merge(int *arr, int *tmp, int start, int mid, int end){
            int li = start;
            int ri = mid;
            int mi = 0;
        
            while(li < mid && ri < end){
                if (arr[li] < arr[ri]){
                    tmp[mi] = arr[li];
                    ++li;
                }
                else{
                    tmp[mi] = arr[ri];
                    ++ri;
                }
                ++mi;
            }
            while(li < mid){
                tmp[mi] = arr[li];
                ++li;
                ++mi;
            }
            while(ri < end){
                tmp[mi] = arr[ri];
                ++ri;
                ++mi;
            }
            memcpy(arr + start, tmp, sizeof(int) * (end - start));
        }
            

            </pre>
</code>
