<h1>Quicksort with lomuto partitioning</h1>

<p>Quick sort is a fast sorting algorithm with average complexity of O(n log n)

<p>Here's a quicksort with lomuto partitioning, no randomization:(Thanks Anthony!)

<code>
    <pre>
        void quicksort_lomuto_norand(int *arr, int start, int end){
        if (start >= end)
        {
        return;
        }
        
        int p = lomuto_partition(arr, start, end, start);
        quicksort_lomuto_norand(arr, start, p-1);
        quicksort_lomuto_norand(arr, p+1, end);
        }
        
        
        int lomuto_partition(int *arr, int start, int end, int pi)
        {
        int pv = arr[pi];
        int si = start;
        
        SWAP(arr, pi, end);
        
        for (int i = start; i < end; ++i)
            {
            if (global_kill_flag)
            {
            exit(1);
            }
            
            if (arr[i] <= pv)
            {
            SWAP(arr, si, i);
            ++si;
            }
            }
            
            SWAP(arr, si, end);
            return si;
            }
            
            
            </pre>
</code>

<p> Heres quicksort using lomuto_partition but with randomization!

<code>
    <pre>
        void quicksort_lomuto_rand(int *arr, int start, int end)
        {
        if (start >= end)
        {
        return;
        }
        
        int p = lomuto_partition(arr, start, end, RAND_RANGE(start, end));
        quicksort_lomuto_rand(arr, start, p-1);
        quicksort_lomuto_rand(arr, p+1, end);
        }
    </pre>
</code>


<h1>Quicksort with hoare partitioning</h1>

<p>Heres quicksort with hoare partitioning, no randomization: (Thanks Anothony!)

<code>
    <pre>
        void quicksort_hoare_norand(int *arr, int start, int end){
        if (start >= end)
        {
        return;
        }
        
        int p = hoare_partition(arr, start, end, start);
        quicksort_hoare_norand(arr, start, p);
        quicksort_hoare_norand(arr, p+1, end);
        }
        
        
        int hoare_partition(int *arr, int start, int end, int pi)
        {
        int i = start-1;
        int j = end+1;
        int pv = arr[pi];
        
        while(1)
        {
        if (global_kill_flag)
        {
        exit(1);
        }
        
        while(arr[++i] < pv);
            while(arr[--j] > pv);
            if (i < j)
                {
                SWAP(arr, i, j);
                }
                else
                {
                return j;
                }
                }
                }
                
                </pre>
</code>

<p> Heres Quicksort using hoare partitioning, but with randomization!

<code>
    <pre>
        void quicksort_hoare_rand(int *arr, int start, int end)
        {
        if (start >= end)
        {
        return;
        }
        
        int p = hoare_partition(arr, start, end, RAND_RANGE(start, end));
        quicksort_hoare_rand(arr, start, p);
        quicksort_hoare_rand(arr, p+1, end);
        }
        
    </pre>
</code>