<h1>Quicksort (lomuto partitioning)</h1>

<p>Quicksort is a fast sorting algorithm used in many standard libraries. This algorithm can handle large data sets very quickly. Crank the problem size up to a million and watch it complete in about the same time than it takes selection sort to finish on just a few thousand.

<p>Average complexity: O(n log n)<br>
Worst Case: O(n^2)<br>
Best Case: O(n log n)<br>

<h3>Here's quicksort with lomuto partitioning, no randomization: (Thanks <a href = "http://huskyalgo.com">Anthony</a>!)</h3>

<code>
<pre>
    void quicksort_lomuto_norand(int *arr, int start, int end){
        if (start >= end){
            return;
        }
    
        int p = lomuto_partition(arr, start, end, start);
        quicksort_lomuto_norand(arr, start, p-1);
        quicksort_lomuto_norand(arr, p+1, end);
    }


    int lomuto_partition(int *arr, int start, int end, int pi){
        int pv = arr[pi];
        int si = start;

        SWAP(arr, pi, end);

        for (int i = start; i < end; ++i){
            if (global_kill_flag){
                exit(1);
            }
    
            if (arr[i] <= pv){
                SWAP(arr, si, i);
                ++si;
            }
        }
    
        SWAP(arr, si, end);
        return si;
    }


</pre>
</code>

<h3> Here's quicksort using lomuto partitioning and randomization:</h3>

<code>
<pre>
    void quicksort_lomuto_rand(int *arr, int start, int end){
        if (start >= end){
            return;
        }
    
        int p = lomuto_partition(arr, start, end, RAND_RANGE(start, end));
        quicksort_lomuto_rand(arr, start, p-1);
        quicksort_lomuto_rand(arr, p+1, end);
    }
</pre>
</code>